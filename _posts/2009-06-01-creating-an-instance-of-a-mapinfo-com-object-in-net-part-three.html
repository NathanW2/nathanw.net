---
layout: post
title: Creating an instance of a Mapinfo COM object in .NET - Part Three
tags:
- .NET
- Mapbasic
- mapinfo
- mapinfo interop
- mapinfo ole
- Mapinfo Programming
- mapping
status: publish
type: post
published: true
meta:
  _edit_last: '4008903'
  reddit: a:2:{s:5:"count";s:1:"0";s:4:"time";s:10:"1327110068";}
---
In part three of the series <a href="http://woostuff.wordpress.com/2009/04/01/com-instance-mapinfo-main/">Creating a instance of a Mapinfo COM object in .NET</a>, I'm going to be talking about <strong>creating an instance of Mapinfo's COM object using Activator.CreateInstace but also allowing you to have strong typed access to Mapinfo's members</strong>.  This approach unlike the approach outlined in <a href="http://woostuff.wordpress.com/2009/05/06/creating-a-instance-of-a-mapinfo-com-object-in-net-part-two/">part two</a>, will allow for your application to be Mapinfo version independent without having to use reflection to get access to <em>Do</em> and <em>Eval</em>

<em>If you haven't read part <a href="http://woostuff.wordpress.com/2009/04/01/com-instance-part-one/">one </a>and <a href="http://woostuff.wordpress.com/2009/05/06/creating-a-instance-of-a-mapinfo-com-object-in-net-part-two/">two </a> I would recommend reading them first as it will give you an understanding of where this post is heading.</em>
<h2>Step 1: Adding a referance to Mapinfo.</h2>
As this method requires us to get access to some of the interfaces that Mapinfo provides, we will need to add a reference to Mapinfo like we did in first step  in part one.

To save on re-explaining the whole process here again, I will wait while you head over to part <a href="http://woostuff.wordpress.com/2009/04/01/com-instance-part-one/">one</a> and follow the process outlined in step 1.  Make sure that you come back here after you have completed step 1.
<h2>Step 2: Creating the instance</h2>
Now that you are back, we can continue.

The process in this step is similar to the process outlined in Part two step 1, however things will differ a little bit.

If you have a look at the Interop.Mapinfo.dll in the object browser of visual studio you will notice that the class called <em>MapinfoApplicationClass</em>, implments a interface called <em>DMapinfo</em>.
<img class="alignleft size-full wp-image-200" title="DMapinfo" src="http://woostuff.files.wordpress.com/2009/06/dmapinfo1.jpg" alt="DMapinfo" width="219" height="558" />

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

Does that <em>MapinfoApplicationClass</em> class look familiar?  It should as it is what we used to create the Mapinfo instance in part one of this series, but we don't need that class here so we will just forget about it.  What we do need is that interface called <em>DMapinfo</em> as it provides all the methods that we need to interact with Mapinfo.

If we have the code that we used in part two step 1 for creating the instance of Mapinfo.

[sourcecode language='csharp']
Type mapinfotype = Type.GetTypeFromProgID("Mapinfo.Application");
object instance = Activator.CreateInstance(mapinfotype);
[/sourcecode]

now this code is great and all but we run into the problem that we had in part two where C# doesn't support late binding so we have to use reflection which just feels dirty. There has to be a better way.

What object is Activator.CreateInstace returning in the above code anyway?

Turns out that the object that it returns also implements the interface <em>DMapinfo</em>, this is good for us as it allows us to cast the object returned from Activator.CreateInstance() to the type <em>DMapinfo</em>.  If we go and add the right casting to the code it should now look like the following.

[sourcecode language='csharp']
Type mapinfotype = Type.GetTypeFromProgID("Mapinfo.Application");
DMapInfo instance = (DMapInfo)Activator.CreateInstance(mapinfotype);
[/sourcecode]

Cool, so we have created a instance of Mapinfo and casted it to the type <em>DMapinfo</em> now we should be able to do something useful with it.

<h2>Step 3: Using the object.</h2>
Because we have casted our object to the interface called <em>DMapinfo</em>, we can now get strongly typed access to Mapinfo's Do and Eval method. No more reflection needed :).

Some sample code:
[sourcecode language='csharp']
Type mapinfotype = Type.GetTypeFromProgID("Mapinfo.Application");
DMapInfo instance = (DMapInfo)Activator.CreateInstance(mapinfotype);

instance.Do("Print 1234567");
string value = instance.Eval("NumTables()");
[/sourcecode]

<h2>More information on DMapinfo.</h2>
If we have a look at the GUID on the top of the <em>DMapinfo</em> interface you will notice that it looks something like this:

[sourcecode language='csharp']
[Guid("1D42EC63-7B28-11CE-B83D-00AA002C4F58")]
public interface DMapInfo
[/sourcecode]

This GUID for DMapinfo, which unlike the GUID for the MapinfoApplicationClass is the same for every Mapinfo version.  
Because it is the same we can create Mapinfo using Activator.CreateInstance() which will return a COM object, cast it DMapinfo and by making calls against the interface we don't have to worry about what version of Mapinfo the client is running.

<h2>Summing up: Pros and Cons</h2>
In this post I have outlined how you can create an instance of Mapinfo using Activator.CreateInstance() and cast the return object to the interface called DMapinfo. This technique allows us to have Mapinfo version independence while still maintaining our type safety and compiler support.

<strong><em>Pros</em></strong>
<ul>
	<li>Allows Mapinfo version independence.</li>
        <li>Strong Typed</li>
        <li>Cleaner then having to use reflection.</li>
        <li>Faster method calling then using reflection.</li>
</ul>
<strong><em>Cons</em></strong>
<ul>
       <li>No real cons</li>
</ul>

